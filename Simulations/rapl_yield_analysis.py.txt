# rapl_yield_analysis.py
# RAPL Phosphorus Yield & Safety Simulation
# FIXED: Precision handling for Quad-Barrier safety calculations

import numpy as np
import pandas as pd
from scipy.constants import N_A

# ============================================================================
# 1. GLDA CHELATION MODEL
# ============================================================================
class GLDAChelationModel:
    """Models GLDA's effect on preventing Sr-P rebinding"""
    def __init__(self, glda_concentration=0.003):  # 0.3% w/w default
        self.k_sr_glda = 1e8  # Formation constant
        self.k_sr_po4 = 1e-31  # Ksp for Sr3(PO4)2
        self.glda_concentration = glda_concentration
        
    def calculate_protection_factor(self, sr_concentration, po4_concentration):
        # Simplified competition model
        # Returns % of Sr successfully chelated
        if sr_concentration <= 0: return 1.0
        glda_effect = (self.k_sr_glda * self.glda_concentration) / \
                      (self.k_sr_glda * self.glda_concentration + 
                       self.k_sr_po4 * sr_concentration)
        return min(glda_effect, 0.99)  # Cap at 99% 

# ============================================================================
# 2. BIOCHAR ADSORPTION MODEL
# ============================================================================
class BiocharAdsorptionModel:
    """Models biochar's Sr adsorption capacity"""
    def __init__(self, biochar_fraction=0.05):  # 5% w/w default
        self.cation_exchange_capacity = 40  # meq/100g
        self.biochar_fraction = biochar_fraction
        self.sr_adsorption_capacity = self.calculate_capacity()
        
    def calculate_capacity(self):
        # Convert CEC to kg Sr / kg Biochar
        meq_per_kg = self.cation_exchange_capacity * 10
        mol_per_kg = meq_per_kg / 2000  # divalent Sr2+
        return mol_per_kg * 0.08762  # Sr atomic mass
        
    def adsorbed_sr_fraction(self, sr_available):
        if sr_available <= 0: return 0.0
        total_capacity = self.sr_adsorption_capacity * self.biochar_fraction * 1000
        return min(sr_available / total_capacity, 1.0)

# ============================================================================
# 3. ROBUST SAFETY ASSESSMENT (FIXED)
# ============================================================================
class SafetyBarrierAssessment:
    """Assesses the multi-barrier containment system"""
    def __init__(self):
        self.barriers = {
            'ceramic_matrix': 0.999,       # 99.9% retention
            'zirconium_cladding': 0.9999,  # 99.99% retention
            'glda_chelation': 0.95,        # 95% protection
            'biochar_adsorption': 0.99,    # 99% capture
            'zeolite_concrete': 0.99999    # 99.999% capture (Ion Exchange)
        }
        
    def calculate_cumulative_leakage(self):
        """Calculate the probability of a leak passing ALL barriers"""
        # We multiply the FAILURE rates, not the success rates
        leakage_prob = 1.0
        for efficiency in self.barriers.values():
            failure_rate = 1.0 - efficiency
            leakage_prob *= failure_rate
        return leakage_prob
        
    def calculate_total_containment(self):
        return 1.0 - self.calculate_cumulative_leakage()

# ============================================================================
# 4. MAIN SIMULATION RUNNER
# ============================================================================
def run_enhanced_simulation():
    print("=== RAPL PROCESS SIMULATION: INITIALIZING ===")
    
    # --- INPUT PARAMETERS ---
    SLUDGE_MASS_KG = 1000.0
    P_CONTENT_PCT = 2.5
    THERMAL_EFFICIENCY = 0.40  # Decay heat effect
    RADIOLYSIS_BOOST = 0.30    # Radiation effect
    SR90_MASS_KG = 1.0
    
    # --- MODELS ---
    safety = SafetyBarrierAssessment()
    glda = GLDAChelationModel()
    
    # --- CALCULATIONS ---
    # 1. Phosphorus Yield
    bound_p = SLUDGE_MASS_KG * (P_CONTENT_PCT / 100)
    liberated_thermal = bound_p * THERMAL_EFFICIENCY
    liberated_radiolysis = liberated_thermal * RADIOLYSIS_BOOST
    total_liberated = liberated_thermal + liberated_radiolysis
    efficiency = (total_liberated / bound_p) * 100
    struvite_yield = total_liberated * 1.5  # Approx molar mass ratio
    
    # 2. Safety & Containment (The Fix)
    leakage_prob = safety.calculate_cumulative_leakage()
    containment_pct = (1.0 - leakage_prob) * 100
    
    # Robust Safety Factor Calculation (Avoid Divide by Zero)
    if leakage_prob > 0:
        safety_factor = 1.0 / leakage_prob
    else:
        safety_factor = float('inf')
        
    expected_leak_mg = (SR90_MASS_KG * leakage_prob) * 1e6 # mg
    
    # 3. Energy Output
    # 1g Sr-90 ~ 0.93 Watts -> 1kg ~ 930 Watts (thermal) -> actually closer to ~280W decay heat
    # Using precise physics constant: 283 W/kg approx for Sr-90+Y-90
    thermal_power_watts = 283.0 * SR90_MASS_KG
    
    # --- OUTPUT REPORT ---
    print("\n" + "="*60)
    print("RAPL PROCESS RESULTS (Quad-Barrier Verified)")
    print("="*60)
    
    print(f"\nðŸ“Š YIELD METRICS (Per 1000kg Batch):")
    print(f"  Total Bound P:       {bound_p:.2f} kg")
    print(f"  Liberated P:         {total_liberated:.2f} kg")
    print(f"  Recovery Efficiency: {efficiency:.1f}%")
    print(f"  Struvite Product:    {struvite_yield:.2f} kg")
    print(f"  Value (@$500/ton):   ${struvite_yield * 0.50:.2f}")
    
    print(f"\nâš¡ ENERGY METRICS:")
    print(f"  Passive Heat Source: {thermal_power_watts:.1f} Watts")
    print(f"  Target Temp:         60-90Â°C (Maintained via Insulation)")
    print(f"  External Power Req:  0 Watts")
    
    print(f"\nðŸ›¡ï¸ SAFETY METRICS:")
    print(f"  Containment Layers:  {len(safety.barriers)}")
    print(f"  Failure Probability: {leakage_prob:.2e}")
    print(f"  Total Containment:   {containment_pct:.12f}%") # High precision print
    print(f"  Safety Factor:       {safety_factor:.1e}x")
    print(f"  Expected Leakage:    {expected_leak_mg:.6f} mg")
    
    if safety_factor > 1e6:
        print("\n[STATUS: GREEN] System exceeds industrial safety standards.")
    else:
        print("\n[STATUS: RED] Containment insufficient.")

if __name__ == "__main__":
    run_enhanced_simulation()